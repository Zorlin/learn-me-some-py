# Challenge: Word Frequency Counter (Multi-Stage)
# Learn dictionaries through text analysis, step by step

[challenge]
id = "word_counter"
name = "Word Frequency Counter"
level = 2
prerequisites = ["dicts_basics", "for_loops"]
concepts_required = ["dict_basics", "dict_key_check", "for_loop_basics"]
concepts_teaches = ["dict_get_method"]  # Extra credit concept

[description]
brief = "Count word frequencies and query them"
detailed = """
Let's build a word frequency analyzer - step by step!

This is how real text analysis works: count words, then answer questions.
We'll start simple and add features as we go.

Stage 1: Count words into a dictionary
Stage 2: Look up individual word counts
Stage 3: Find the total unique words
Stage 4: Find the most common word
"""

[skeleton]
code = '''
# STAGE 1: Count Words
#
# Example:
#   count_words(["cat", "dog", "cat"])
#   Returns: {"cat": 2, "dog": 1}

def count_words(words):
    counts = {}  # Empty dictionary to store word counts

    # TODO: Loop through each word in words
    # For each word, add 1 to its count in the dictionary

    return counts
'''

[validation]
type = "pytest"
test_file = "test_word_counter.py"

[hints]
level_1 = "Use a dictionary to store counts: counts = {}"
level_2 = "Loop through words with: for word in words"
level_3 = "Use counts.get(word, 0) + 1 to safely increment"

[meta]
time_limit_seconds = 600
speed_run_target = 180
points = 150
xp_reward = 150
category = "data_processing"

# ============================================================================
# Stage 1: Basic Counting
# ============================================================================

[stages.stage_1]
name = "Count Words"
description = """
Create a function that counts word frequencies.

```python
def count_words(words):
    # Return a dictionary with word counts
```

**Examples:**
- `count_words(["cat", "dog", "cat"])` → `{"cat": 2, "dog": 1}`
- `count_words(["hello"])` → `{"hello": 1}`
- `count_words([])` → `{}`
"""
skeleton_code = '''
# STAGE 1: Count Words
#
# Example:
#   count_words(["cat", "dog", "cat"])
#   Returns: {"cat": 2, "dog": 1}

def count_words(words):
    counts = {}  # Empty dictionary to store word counts

    # TODO: Loop through each word in words
    # For each word, add 1 to its count in the dictionary

    return counts
'''

[stages.stage_1.hints]
level_1 = "Start with `for word in words:` to loop through each word"
level_2 = "Problem: `counts[word] += 1` crashes if word isn't in the dict yet (KeyError!)"
level_3 = "Use `if word in counts:` to check if the word exists first"
level_4 = """
The pattern: check if word exists, then act accordingly:

```python
for word in words:
    if word in counts:
        counts[word] += 1  # Already seen, add 1
    else:
        counts[word] = 1   # First time, start at 1
```
"""

[stages.stage_1.extra_credit]
title = "Pro Shortcut: .get()"
content = """
Once you understand the if/else pattern, there's a one-liner:

```python
counts[word] = counts.get(word, 0) + 1
```

`.get(word, 0)` returns the count if it exists, or 0 if it's new.
Then we add 1 and store it back. Same result, less code!
"""

# ============================================================================
# Stage 2: COUNT Command
# ============================================================================

[stages.stage_2]
name = "Look Up Counts"
description = """
Now add a function to look up the count for a specific word.

**Keep your `count_words` function!** We'll use it.

```python
def get_count(counts, word):
    # Return the count for a word (0 if not found)
```

**Examples:**
- `get_count({"cat": 2, "dog": 1}, "cat")` → `2`
- `get_count({"cat": 2, "dog": 1}, "bird")` → `0`

Tip: Use `.get()` with a default value!
"""

[stages.stage_2.hints]
level_1 = "Use dict.get(key, default) to safely get a value"
level_2 = "`return counts.get(word, 0)`"

# ============================================================================
# Stage 3: TOTAL Command
# ============================================================================

[stages.stage_3]
name = "Count Unique Words"
description = """
Add a function to count how many unique words there are.

```python
def get_unique_count(counts):
    # Return the number of different words
```

**Examples:**
- `get_unique_count({"cat": 2, "dog": 1})` → `2`
- `get_unique_count({})` → `0`

Hint: The dictionary already has one entry per unique word...
"""

[stages.stage_3.hints]
level_1 = "Each key in the dictionary is a unique word"
level_2 = "Use len() on the dictionary"
level_3 = "`return len(counts)`"

# ============================================================================
# Stage 4: MOST Command
# ============================================================================

[stages.stage_4]
name = "Find Most Common"
description = """
The grand finale! Find the most frequently occurring word.

```python
def get_most_common(counts):
    # Return the word with the highest count
    # Return "" if counts is empty
```

**Examples:**
- `get_most_common({"cat": 5, "dog": 2, "bird": 3})` → `"cat"`
- `get_most_common({})` → `""`

This is trickier! You need to find which key has the maximum value.

Hint: Python's `max()` function can take a `key` parameter...
"""

[stages.stage_4.hints]
level_1 = "You could loop through and track the max, or use max() with key="
level_2 = "max(counts, key=counts.get) returns the key with highest value"
level_3 = """
```python
def get_most_common(counts):
    if not counts:
        return ""
    return max(counts, key=counts.get)
```

The `key=counts.get` tells max() to compare by the dict values, not the keys!
"""

# Hidden path: if they use Counter from collections
[stages.stage_4.hidden_path]
detect_pattern = "Counter"
bonus_xp = 50
achievement = "collections_explorer"
message = "You found Counter from collections! That's the pro way to do this."

# ============================================================================
# Solution
# ============================================================================

[solution]
code = '''
def count_words(words):
    counts = {}
    for word in words:
        counts[word] = counts.get(word, 0) + 1
    return counts

def get_count(counts, word):
    return counts.get(word, 0)

def get_unique_count(counts):
    return len(counts)

def get_most_common(counts):
    if not counts:
        return ""
    return max(counts, key=counts.get)
'''

[adaptive]
fun_factor = "analytical"
weakness_signals = ["dict_key_error", "forgot_get_default", "max_on_empty_dict"]
project_themes = ["text_analysis", "search_engine", "chat_analyzer", "log_processor"]

[emotional_checkpoints]
after_stage_1 = """
Dictionary counting works! This is the core of text analysis.
[RT] if dictionaries are clicking
"""
after_stage_2 = """
You can look up any word's count now. .get() with defaults is powerful!
"""
after_stage_4 = """
You built a complete word frequency analyzer!

Functions you created:
- count_words(words) - counts frequencies
- get_count(counts, word) - looks up a word
- get_unique_count(counts) - counts unique words
- get_most_common(counts) - finds the winner

This is real text processing. Search engines, spam filters,
and AI language models all start with counting words!

[RT] Love data analysis | [LT] Want harder challenges | [Y] What's next?
"""

# Self-teaching note:
#
# This file demonstrates:
# - Dictionaries for counting (Level 2)
# - The .get() method with defaults (Level 2)
# - Using len() on dictionaries (Level 1)
# - max() with key parameter (Level 3)
#
# Breaking into stages prevents overwhelming the learner.
# Each stage teaches ONE concept.
