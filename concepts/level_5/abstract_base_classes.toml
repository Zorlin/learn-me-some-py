# Level 5: Abstract Base Classes

[concept]
id = "abstract_base_classes"
name = "ABCs: Interface Contracts"
level = 5
category = "design_patterns"
order = 4

[content]
lesson = """
## Enforce Required Methods

Abstract Base Classes define interfaces that subclasses MUST implement:

```python
from abc import ABC, abstractmethod

class Weapon(ABC):
    @abstractmethod
    def attack(self) -> int:
        pass

    @abstractmethod
    def durability(self) -> int:
        pass

# Can't instantiate abstract class!
# weapon = Weapon()  # TypeError!

class Sword(Weapon):
    def attack(self) -> int:
        return 10

    def durability(self) -> int:
        return 50

sword = Sword()  # Works! All abstract methods implemented
```

## Missing Methods = Error

```python
class Axe(Weapon):
    def attack(self) -> int:
        return 15
    # Missing durability()!

# axe = Axe()  # TypeError: Can't instantiate abstract class
```

## Default Implementations

Abstract classes can have non-abstract methods:

```python
class Weapon(ABC):
    @abstractmethod
    def attack(self) -> int:
        pass

    def describe(self):  # Not abstract - has default
        return f"A weapon dealing {self.attack()} damage"

class Sword(Weapon):
    def attack(self) -> int:
        return 10

sword = Sword()
print(sword.describe())  # "A weapon dealing 10 damage"
```

## Plugin Pattern

```python
class Plugin(ABC):
    @abstractmethod
    def name(self) -> str:
        pass

    @abstractmethod
    def execute(self, data):
        pass

class SpellCheck(Plugin):
    def name(self) -> str:
        return "Spell Checker"

    def execute(self, text):
        return text.replace("teh", "the")

# All plugins guaranteed to have name() and execute()
plugins = [SpellCheck()]
for plugin in plugins:
    print(f"Running {plugin.name()}")
    result = plugin.execute("Fix teh typo")
```

## ABC vs Protocol

- **ABC**: Requires inheritance, runtime enforcement
- **Protocol**: No inheritance, static type checking only

Use ABC when you want runtime enforcement.
Use Protocol when you want flexibility.
"""

[content.try_it]
prompt = "Create an abstract Shape class with abstract area() method"
starter = '''
from abc import ABC, abstractmethod

# Create abstract Shape class

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    # Implement area()

rect = Rectangle(5, 3)
print(rect.area())  # Should print 15
'''
solution = '''
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self) -> float:
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self) -> float:
        return self.width * self.height

rect = Rectangle(5, 3)
print(rect.area())  # 15
'''

[connections]
prerequisites = ["classes", "decorators"]
enables = ["protocols"]
used_in = []
see_also = ["protocols", "classes"]

[meta]
time_to_read = 55
difficulty = "advanced"
tags = ["abc", "abstract", "design_patterns"]
