# Level 5: Protocols

[concept]
id = "protocols"
name = "Protocols: Structural Typing"
level = 5
category = "type_system"
order = 3

[content]
lesson = """
## Duck Typing + Type Hints

Protocols define interfaces based on structure, not inheritance.
If it has the right methods, it satisfies the protocol!

```python
from typing import Protocol

class Drawable(Protocol):
    def draw(self) -> str:
        ...

class Circle:
    def draw(self) -> str:
        return "⭕"

class Square:
    def draw(self) -> str:
        return "⬜"

def render(obj: Drawable) -> None:
    print(obj.draw())

# Both work - no inheritance needed!
render(Circle())  # ⭕
render(Square())  # ⬜
```

## Why Protocols?

Unlike Abstract Base Classes (ABC), protocols don't require inheritance:

```python
# ABC: Must explicitly inherit
class Animal(ABC):
    @abstractmethod
    def speak(self): pass

class Dog(Animal):  # Must inherit!
    def speak(self): return "Woof"

# Protocol: Just needs the right shape
class AnimalProto(Protocol):
    def speak(self) -> str: ...

class Cat:  # Doesn't inherit anything
    def speak(self) -> str:
        return "Meow"

def make_sound(animal: AnimalProto):
    print(animal.speak())

make_sound(Cat())  # Works! Cat has speak()
```

## Runtime Checking

Use `@runtime_checkable` for isinstance():

```python
from typing import Protocol, runtime_checkable

@runtime_checkable
class HasName(Protocol):
    name: str

class Person:
    def __init__(self, name: str):
        self.name = name

p = Person("Alice")
print(isinstance(p, HasName))  # True
```

## Common Protocols

```python
class Sized(Protocol):
    def __len__(self) -> int: ...

class Comparable(Protocol):
    def __lt__(self, other) -> bool: ...

def is_empty(container: Sized) -> bool:
    return len(container) == 0

# Works with lists, strings, custom classes...
```
"""

[content.try_it]
prompt = "Create a Closeable protocol for objects with close() method"
starter = '''
from typing import Protocol

# Create Closeable protocol

class File:
    def close(self):
        print("Closing file")

class Socket:
    def close(self):
        print("Closing socket")

def cleanup(resource):  # Add type hint
    resource.close()
'''
solution = '''
from typing import Protocol

class Closeable(Protocol):
    def close(self) -> None:
        ...

class File:
    def close(self) -> None:
        print("Closing file")

class Socket:
    def close(self) -> None:
        print("Closing socket")

def cleanup(resource: Closeable) -> None:
    resource.close()

cleanup(File())    # Closing file
cleanup(Socket())  # Closing socket
'''

[connections]
prerequisites = ["type_hints", "classes", "abstract_base_classes"]
enables = []
used_in = []
see_also = ["abstract_base_classes", "type_hints"]

[meta]
time_to_read = 55
difficulty = "advanced"
tags = ["protocols", "typing", "duck_typing"]
