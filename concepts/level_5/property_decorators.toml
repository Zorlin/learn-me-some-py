# Level 5: Property Decorators

[concept]
id = "property_decorators"
name = "Properties: Computed Attributes"
level = 5
category = "oop"
order = 1

[content]
lesson = """
## Methods That Look Like Attributes

Properties let you write methods that are accessed like attributes:

```python
class Character:
    def __init__(self, name, hp, max_hp):
        self.name = name
        self._hp = hp
        self._max_hp = max_hp

    @property
    def hp(self):
        return self._hp

    @hp.setter
    def hp(self, value):
        # Validate and clamp
        self._hp = max(0, min(value, self._max_hp))

    @property
    def hp_percentage(self):
        return (self._hp / self._max_hp) * 100

hero = Character("Hero", 100, 100)
print(hero.hp)           # 100 (no parentheses!)
print(hero.hp_percentage) # 100.0

hero.hp = 50             # Calls setter
hero.hp = -10            # Clamped to 0
hero.hp = 9999           # Clamped to max_hp
```

## Read-Only Properties

Don't define a setter for computed values:

```python
class Circle:
    def __init__(self, radius):
        self.radius = radius

    @property
    def area(self):
        return 3.14159 * self.radius ** 2

circle = Circle(5)
print(circle.area)  # 78.54 (computed)
# circle.area = 100  # Error! Can't set read-only property
```

## Validation with Setters

```python
class User:
    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, value):
        if not isinstance(value, int):
            raise TypeError("Age must be integer")
        if value < 0 or value > 150:
            raise ValueError("Age must be 0-150")
        self._age = value
```

## Common Mistake: Infinite Recursion

```python
# WRONG - infinite recursion!
class Bad:
    @property
    def name(self):
        return self.name  # Calls itself!

# RIGHT - use different name for storage
class Good:
    @property
    def name(self):
        return self._name  # Different attribute
```

## When to Use Properties

- **Computed values**: area, full_name, is_valid
- **Validation**: Ensure values are within range
- **Lazy loading**: Compute expensive values on demand
- **Backwards compatibility**: Turn attribute into method
"""

[content.try_it]
prompt = "Create a Temperature class with celsius and fahrenheit properties"
starter = '''
class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius

    @property
    def celsius(self):
        return self._celsius

    # Add fahrenheit property (read-only)
    # Formula: F = C * 9/5 + 32

temp = Temperature(100)
print(temp.fahrenheit)  # Should print 212.0
'''
solution = '''
class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius

    @property
    def celsius(self):
        return self._celsius

    @property
    def fahrenheit(self):
        return self._celsius * 9/5 + 32

temp = Temperature(100)
print(temp.fahrenheit)  # 212.0
'''

[connections]
prerequisites = ["classes", "decorators"]
enables = ["descriptors"]
used_in = []
see_also = ["decorators", "classes"]

[meta]
time_to_read = 55
difficulty = "advanced"
tags = ["property", "decorators", "oop"]
