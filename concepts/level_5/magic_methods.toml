# Level 5: Magic Methods

[concept]
id = "magic_methods"
name = "Magic Methods: Operator Overloading"
level = 5
category = "oop"
order = 0

[content]
lesson = """
## Make Your Objects Feel Built-In

Magic methods (dunder = double underscore) let your objects work with Python's operators.

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)

    def __str__(self):
        return f"Vector({self.x}, {self.y})"

    def __repr__(self):
        return f"Vector(x={self.x}, y={self.y})"

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

v1 = Vector(1, 2)
v2 = Vector(3, 4)

print(v1 + v2)  # Vector(4, 6)
print(v1 * 3)   # Vector(3, 6)
```

## Common Magic Methods

| Method | Trigger | Example |
|--------|---------|---------|
| `__str__` | str(obj), print() | User-friendly output |
| `__repr__` | repr(obj) | Debug output |
| `__add__` | + operator | a + b |
| `__eq__` | == operator | a == b |
| `__lt__` | < operator | a < b |
| `__len__` | len(obj) | len(container) |
| `__getitem__` | obj[key] | container[0] |
| `__contains__` | in operator | x in container |
| `__call__` | obj() | callable object |

## Container Magic

```python
class Inventory:
    def __init__(self):
        self._items = {}

    def __getitem__(self, key):
        return self._items.get(key, 0)

    def __setitem__(self, key, value):
        self._items[key] = value

    def __contains__(self, key):
        return key in self._items

    def __len__(self):
        return len(self._items)

inv = Inventory()
inv["sword"] = 1
print(inv["sword"])        # 1
print("shield" in inv)     # False
print(len(inv))            # 1
```

## __str__ vs __repr__

- `__str__`: User-friendly, for print()
- `__repr__`: Debug output, for developers

```python
class Card:
    def __init__(self, rank, suit):
        self.rank = rank
        self.suit = suit

    def __str__(self):
        return f"{self.rank} of {self.suit}"

    def __repr__(self):
        return f"Card({self.rank!r}, {self.suit!r})"

card = Card("Ace", "Spades")
print(str(card))   # Ace of Spades
print(repr(card))  # Card('Ace', 'Spades')
```
"""

[content.try_it]
prompt = "Create a Money class with __add__ and __str__"
starter = '''
class Money:
    def __init__(self, amount):
        self.amount = amount

    # Add __add__ and __str__ methods

m1 = Money(10.50)
m2 = Money(5.25)
print(m1 + m2)  # Should print "$15.75"
'''
solution = '''
class Money:
    def __init__(self, amount):
        self.amount = amount

    def __add__(self, other):
        return Money(self.amount + other.amount)

    def __str__(self):
        return f"${self.amount:.2f}"

m1 = Money(10.50)
m2 = Money(5.25)
print(m1 + m2)  # $15.75
'''

[connections]
prerequisites = ["classes", "decorators"]
enables = ["descriptors"]
used_in = []
see_also = ["classes"]

[meta]
time_to_read = 65
difficulty = "advanced"
tags = ["magic_methods", "dunder", "oop"]
