# Level 3: Decorators

[concept]
id = "decorators"
name = "Decorators: Modify Functions"
level = 3
category = "advanced"
order = 8

[content]
lesson = """
## Adding Superpowers

Decorators wrap functions to add extra behavior:

```python
@timer
def slow_function():
    # Some heavy computation
    pass

# Same as: slow_function = timer(slow_function)
```

## A Simple Decorator

```python
def debug(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__}")
        result = func(*args, **kwargs)
        print(f"Returned {result}")
        return result
    return wrapper

@debug
def add(a, b):
    return a + b

add(2, 3)
# Output:
# Calling add
# Returned 5
```

## Common Built-in Decorators

```python
class Player:
    def __init__(self, hp):
        self._hp = hp

    @property  # Makes method look like attribute
    def hp(self):
        return self._hp

    @staticmethod  # No self needed
    def max_level():
        return 100

player = Player(50)
print(player.hp)          # 50 (no parentheses!)
print(Player.max_level()) # 100
```

## The @dataclass Decorator

```python
from dataclasses import dataclass

@dataclass
class Item:
    name: str
    value: int
    weight: float = 1.0

# Automatically creates __init__, __repr__, etc!
sword = Item("Sword", 100)
print(sword)  # Item(name='Sword', value=100, weight=1.0)
```

## Creating a Timer Decorator

```python
import time

def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        elapsed = time.time() - start
        print(f"{func.__name__} took {elapsed:.4f}s")
        return result
    return wrapper

@timer
def process_data():
    time.sleep(0.1)
    return "Done"

process_data()  # "process_data took 0.1005s"
```
"""

[content.try_it]
prompt = "Create a decorator that prints 'Before' and 'After' around function calls"
starter = '''
def before_after(func):
    # Your decorator here
    pass

@before_after
def say_hello():
    print("Hello!")

say_hello()
# Should print:
# Before
# Hello!
# After

'''
solution = '''
def before_after(func):
    def wrapper(*args, **kwargs):
        print("Before")
        result = func(*args, **kwargs)
        print("After")
        return result
    return wrapper

@before_after
def say_hello():
    print("Hello!")

say_hello()
'''

[connections]
prerequisites = ["functions"]
enables = ["dataclasses", "property_decorators"]
used_in = []
see_also = ["functions"]

[meta]
time_to_read = 60
difficulty = "advanced"
tags = ["decorators", "metaprogramming", "advanced"]
