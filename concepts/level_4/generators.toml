# Level 4: Generators

[concept]
id = "generators"
name = "Generators: Lazy Evaluation"
level = 4
category = "advanced_iteration"
order = 6

[content]
lesson = """
## Values On Demand

Generators create values one at a time, only when needed.
Like a vending machine - items dispensed one by one, not all at once.

```python
def countdown(n):
    while n > 0:
        yield n
        n -= 1

for num in countdown(5):
    print(num)  # 5, 4, 3, 2, 1
```

## `yield` vs `return`

- `return` - exits function, returns value
- `yield` - pauses function, returns value, resumes on next()

```python
def fibonacci():
    a, b = 0, 1
    while True:  # Infinite!
        yield a
        a, b = b, a + b

fib = fibonacci()
print(next(fib))  # 0
print(next(fib))  # 1
print(next(fib))  # 1
print(next(fib))  # 2
```

## Memory Efficiency

```python
# List - ALL in memory
squares = [x**2 for x in range(1000000)]  # Uses ~8MB!

# Generator - computed as needed
squares = (x**2 for x in range(1000000))  # Uses ~200 bytes!
```

## Generator Expression

Like list comprehension, but with `()`:

```python
# List comprehension
[x**2 for x in range(10)]  # Creates list

# Generator expression
(x**2 for x in range(10))  # Creates generator

# Works directly in functions
total = sum(x**2 for x in range(100))
```

## Real Example: Wave Spawner

```python
def wave_spawner(base_enemies=3):
    wave_num = 1
    while True:
        enemy_count = base_enemies + (wave_num - 1) * 2
        enemy_hp = 50 * wave_num
        yield {
            'wave': wave_num,
            'enemies': enemy_count,
            'hp': enemy_hp
        }
        wave_num += 1

spawner = wave_spawner()
for _ in range(3):
    wave = next(spawner)
    print(f"Wave {wave['wave']}: {wave['enemies']} enemies")
```

## Gotcha: Single Use

Generators are exhausted after iteration:

```python
gen = (x for x in range(5))
list(gen)  # [0, 1, 2, 3, 4]
list(gen)  # [] - exhausted!
```
"""

[content.try_it]
prompt = "Create a generator that yields even numbers from 0 to n"
starter = '''
def even_numbers(n):
    # Yield even numbers from 0 up to n
    pass

for num in even_numbers(10):
    print(num)  # Should print 0, 2, 4, 6, 8, 10
'''
solution = '''
def even_numbers(n):
    for i in range(0, n + 1, 2):
        yield i

for num in even_numbers(10):
    print(num)  # 0, 2, 4, 6, 8, 10
'''

[connections]
prerequisites = ["functions", "for_loops", "comprehensions"]
enables = []
used_in = []
see_also = ["comprehensions"]

[meta]
time_to_read = 55
difficulty = "intermediate"
tags = ["generators", "yield", "lazy_evaluation"]
