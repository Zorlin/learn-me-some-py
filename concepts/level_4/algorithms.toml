# Level 4: Algorithms

[concept]
id = "algorithms"
name = "Algorithms: Problem-Solving Recipes"
level = 4
category = "problem_solving"
order = 2

[content]
lesson = """
## Recipes for Solving Problems

Algorithms are step-by-step recipes. Learn the classics
and you'll recognize patterns everywhere.

## Binary Search

Find items in a sorted list super fast:

```python
def binary_search(items, target):
    left, right = 0, len(items) - 1

    while left <= right:
        mid = (left + right) // 2

        if items[mid] == target:
            return mid
        elif items[mid] < target:
            left = mid + 1  # Search right half
        else:
            right = mid - 1  # Search left half

    return -1  # Not found

# O(log n) - searches 1 million items in ~20 steps!
scores = [100, 250, 500, 1000, 2500, 5000]
index = binary_search(scores, 1000)  # Returns 3
```

## Breadth-First Search (BFS)

Find shortest paths in graphs:

```python
from collections import deque

def bfs_shortest_path(graph, start, goal):
    queue = deque([(start, [start])])
    visited = {start}

    while queue:
        node, path = queue.popleft()

        if node == goal:
            return path

        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))

    return None

# Dungeon map
dungeon = {
    'entrance': ['hallway'],
    'hallway': ['entrance', 'room1', 'room2'],
    'room1': ['hallway', 'boss'],
    'room2': ['hallway'],
    'boss': ['room1']
}

path = bfs_shortest_path(dungeon, 'entrance', 'boss')
# ['entrance', 'hallway', 'room1', 'boss']
```

## Big O Notation

How algorithms scale:

| Notation | Name | Example |
|----------|------|---------|
| O(1) | Constant | Dict lookup |
| O(log n) | Logarithmic | Binary search |
| O(n) | Linear | Simple loop |
| O(n log n) | Linearithmic | Good sorting |
| O(nÂ²) | Quadratic | Nested loops |

## Python's Built-in Sort

Python's `sort()` is highly optimized - use it!

```python
# Timsort: O(n log n)
items.sort()
items.sort(key=lambda x: x.value)
```
"""

[content.try_it]
prompt = "Write a simple linear search that returns the index of an item, or -1 if not found"
starter = '''
def linear_search(items, target):
    # Find target in items, return its index
    # Return -1 if not found
    pass

print(linear_search([5, 3, 8, 1], 8))  # Should print 2
print(linear_search([5, 3, 8, 1], 9))  # Should print -1
'''
solution = '''
def linear_search(items, target):
    for i, item in enumerate(items):
        if item == target:
            return i
    return -1

print(linear_search([5, 3, 8, 1], 8))  # 2
print(linear_search([5, 3, 8, 1], 9))  # -1
'''

[connections]
prerequisites = ["functions", "for_loops", "lists"]
enables = ["graphs_and_dags"]
used_in = []
see_also = ["sorted_function"]

[meta]
time_to_read = 65
difficulty = "intermediate"
tags = ["algorithms", "problem_solving", "efficiency"]
