# Level 4: Context Managers
# Prerequisite for: resource management, clean code

[concept]
id = "context_managers"
name = "Context Managers: Automatic Resource Cleanup"
level = 4
category = "resource_management"
prerequisites = ["file_io", "exceptions", "classes"]
unlocks = ["custom_context_managers", "resource_pools", "transaction_management"]

[description]
brief = "Automatically set up and tear down resources with 'with' statement"
detailed = """
Context managers ensure resources are properly cleaned up, even if errors occur.
It's like auto-save in games - you never forget to save progress.

```python
with open('save.json', 'w') as f:
    f.write(data)
# File automatically closed, even if error occurs!
```

Context managers handle:
- File opening/closing
- Lock acquiring/releasing
- Database connections
- Temporary state changes
"""

[syntax]
basic = """
with context_manager as variable:
    # Use resource
    pass
# Resource automatically cleaned up
"""

multiple = """
with open('in.txt') as f_in, open('out.txt', 'w') as f_out:
    data = f_in.read()
    f_out.write(data)
"""

nested = """
with outer() as o:
    with inner() as i:
        # Use both
        pass
"""

no_variable = """
with lock:  # Don't need to use the object
    # Critical section
    pass
"""

[examples]
basic = """
# File handling (most common use)
with open('game.log', 'a') as log:
    log.write('Player entered dungeon\n')
# File automatically closed

# Same as:
log = open('game.log', 'a')
try:
    log.write('Player entered dungeon\n')
finally:
    log.close()
"""

advanced = """
from contextlib import contextmanager
import time

@contextmanager
def timer(name):
    '''Context manager to time code blocks'''
    start = time.time()
    print(f"Starting {name}...")
    try:
        yield
    finally:
        elapsed = time.time() - start
        print(f"{name} took {elapsed:.4f}s")

with timer("world generation"):
    # Generate world
    time.sleep(0.1)
# Output:
# Starting world generation...
# world generation took 0.1002s
"""

real_world = """
from contextlib import contextmanager
import json

class GameState:
    def __init__(self, save_file):
        self.save_file = save_file
        self.data = {}

    @contextmanager
    def transaction(self):
        '''Save game state only if no errors occur'''
        # Load current state
        try:
            with open(self.save_file) as f:
                original = json.load(f)
        except FileNotFoundError:
            original = {}

        self.data = original.copy()

        try:
            yield self.data  # Let user modify data
            # If we get here, save was successful
            with open(self.save_file, 'w') as f:
                json.dump(self.data, f, indent=2)
        except Exception:
            # Error occurred, restore original
            self.data = original
            raise

# Usage
game = GameState('save.json')
with game.transaction() as state:
    state['level'] = 5
    state['hp'] = 100
    # If error occurs here, save is rolled back
# State saved only if no errors
"""

[creating_context_managers]
class_based = """
class FileLogger:
    def __init__(self, filename):
        self.filename = filename
        self.file = None

    def __enter__(self):
        self.file = open(self.filename, 'a')
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file:
            self.file.close()
        # Return False to propagate exceptions
        return False

with FileLogger('game.log') as log:
    log.write('Event logged\n')
"""

function_based = """
from contextlib import contextmanager

@contextmanager
def temp_setting(key, value):
    '''Temporarily change a setting'''
    old_value = settings.get(key)
    settings[key] = value
    try:
        yield
    finally:
        settings[key] = old_value

with temp_setting('debug_mode', True):
    # Debug mode enabled
    run_test()
# Debug mode restored
"""

[common_mistakes]
forgetting_exit = """
# WRONG: Missing __exit__
class Broken:
    def __enter__(self):
        return self
    # Missing __exit__!

# RIGHT: Both required
class Works:
    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        # Cleanup here
        return False
"""

swallowing_exceptions = """
# WRONG: __exit__ returns True (swallows exceptions)
class Broken:
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.cleanup()
        return True  # Exception hidden!

# RIGHT: Return False or None
class Works:
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.cleanup()
        return False  # Exception propagates
"""

not_using_with = """
# WRONG: Manual cleanup (easy to forget!)
f = open('file.txt')
try:
    data = f.read()
finally:
    f.close()

# RIGHT: Automatic cleanup
with open('file.txt') as f:
    data = f.read()
"""

[dunder_methods]
enter = "__enter__(self) - Set up resource, return it"
exit = "__exit__(self, exc_type, exc_val, exc_tb) - Clean up, return False"

[contextlib_utilities]
contextmanager = "@contextmanager - Decorator to create context managers from generators"
closing = "closing(obj) - Calls obj.close() on exit"
suppress = "suppress(*exceptions) - Suppress specific exceptions"
redirect_stdout = "redirect_stdout(file) - Redirect print() output"

[gotchas]
exit_always_runs = "__exit__ runs even if exception occurs"
return_value = "__enter__ return value is what 'as' captures"
exception_info = "__exit__ gets exception info if one occurred"
nested_order = "Nested context managers exit in reverse order (LIFO)"

[gamepad_tutorial]
text = """
ðŸŽ® CONTEXT MANAGER MODE:
- Press Y to wrap code in 'with' statement
- Press A to create custom context manager
- Press X to convert try/finally to 'with'
- RB suggests context manager opportunities
- LB shows resource lifecycle
- Hold LT to see cleanup guarantees
"""

[challenges]
starter = "context_managers_file_handling"
intermediate = "context_managers_timer"
mastery = "context_managers_transaction"

[fun_facts]
pythonic = "'with' is the Pythonic way to manage resources"
lock_pattern = "threading.Lock() is a context manager"
database = "Database connections use context managers for transactions"
custom_easy = "@contextmanager makes creating context managers super easy!"

[fun_factor]
type = "safety"
description = "Never leak resources or forget cleanup"
examples = ["Auto-save system", "Temporary god mode", "Transaction rollback"]

[adaptive]
weakness_signals = ["missing_exit", "swallowed_exceptions", "manual_cleanup"]
strength_indicators = ["proper_with_usage", "custom_managers", "clean_patterns"]
