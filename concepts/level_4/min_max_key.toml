# Level 4: min/max with key

[concept]
id = "min_max_key"
name = "min() and max() with key="
level = 4
category = "functional"
order = 7

[content]
lesson = """
## Custom Comparisons

`min()` and `max()` can find extremes with custom logic:

```python
players = [
    {"name": "Alice", "hp": 50},
    {"name": "Bob", "hp": 30},
    {"name": "Charlie", "hp": 80}
]

weakest = min(players, key=lambda p: p["hp"])
# {"name": "Bob", "hp": 30}

strongest = max(players, key=lambda p: p["hp"])
# {"name": "Charlie", "hp": 80}
```

## How It Works

The `key=` parameter tells Python **what to compare**:

```python
# Compare by second element
pairs = [(1, 100), (2, 50), (3, 200)]

min(pairs)                      # (1, 100) - compares first element
min(pairs, key=lambda p: p[1])  # (2, 50) - compares second element
```

## Common Patterns

```python
# Shortest/longest string
words = ["hello", "hi", "greetings"]
shortest = min(words, key=len)  # "hi"
longest = max(words, key=len)   # "greetings"

# Closest enemy
import math

def distance(enemy):
    return math.sqrt(enemy["x"]**2 + enemy["y"]**2)

closest = min(enemies, key=distance)
farthest = max(enemies, key=distance)
```

## Returns the ITEM, Not the Key

Important: you get back the whole item!

```python
players = [("Alice", 100), ("Bob", 150)]
winner = max(players, key=lambda p: p[1])
# winner is ("Bob", 150), not 150!
```

## Handle Empty Lists

```python
# WRONG - crashes on empty list
# target = min(enemies, key=lambda e: e.hp)

# RIGHT - provide default
target = min(enemies, key=lambda e: e.hp, default=None)
if target:
    print(f"Targeting {target['name']}")
```

## Why Not Just Sort?

`min()`/`max()` are O(n) - single pass.
`sorted()` is O(n log n) - much slower for large lists!

```python
# Fast: O(n)
strongest = max(players, key=lambda p: p.hp)

# Slow: O(n log n)
strongest = sorted(players, key=lambda p: p.hp)[-1]
```
"""

[content.try_it]
prompt = "Find the item with the highest value-to-weight ratio"
starter = '''
items = [
    {"name": "Gold Ring", "value": 100, "weight": 1},
    {"name": "Iron Sword", "value": 50, "weight": 10},
    {"name": "Diamond", "value": 500, "weight": 2}
]

# Find item with best value per weight

'''
solution = '''
items = [
    {"name": "Gold Ring", "value": 100, "weight": 1},
    {"name": "Iron Sword", "value": 50, "weight": 10},
    {"name": "Diamond", "value": 500, "weight": 2}
]

best = max(items, key=lambda i: i["value"] / i["weight"])
print(f"{best['name']} - {best['value']/best['weight']:.1f} value/weight")
# Diamond - 250.0 value/weight
'''

[connections]
prerequisites = ["lambda", "lists"]
enables = []
used_in = []
see_also = ["sorted_function", "lambda"]

[meta]
time_to_read = 50
difficulty = "intermediate"
tags = ["min", "max", "key", "functional"]
