# Level 2: String Methods
# Prerequisite for: text parsing, user input, data processing

[concept]
id = "string_methods"
name = "String Methods: Text Manipulation"
level = 2
prerequisites = ["strings", "lists_basics"]

[description]
brief = "Built-in functions to slice, split, join, and transform text"
detailed = """
Strings come with powerful methods for text manipulation. Essential for
parsing commands, formatting output, and processing player input.

```python
command = "ATTACK goblin"
parts = command.split()  # ["ATTACK", "goblin"]
action = parts[0].lower()  # "attack"

# Join list into string
items = ["sword", "shield", "potion"]
inventory_text = ", ".join(items)
print(inventory_text)  # "sword, shield, potion"
```
"""

[methods]
# Case conversion
upper = "Convert to uppercase: 'hello'.upper() â†’ 'HELLO'"
lower = "Convert to lowercase: 'HELLO'.lower() â†’ 'hello'"
title = "Title case: 'hello world'.title() â†’ 'Hello World'"
capitalize = "Capitalize first letter: 'hello'.capitalize() â†’ 'Hello'"

# Splitting and joining
split = "Split by whitespace: 'a b c'.split() â†’ ['a', 'b', 'c']"
split_delimiter = "Split by delimiter: 'a,b,c'.split(',') â†’ ['a', 'b', 'c']"
join = "Join list with separator: ','.join(['a', 'b']) â†’ 'a,b'"

# Searching
find = "Find substring position: 'hello'.find('ll') â†’ 2 (or -1 if not found)"
index = "Find substring (error if missing): 'hello'.index('ll') â†’ 2"
count = "Count occurrences: 'banana'.count('a') â†’ 3"
startswith = "Check prefix: 'hello'.startswith('hel') â†’ True"
endswith = "Check suffix: 'hello'.endswith('lo') â†’ True"

# Checking
isdigit = "All digits? '123'.isdigit() â†’ True"
isalpha = "All letters? 'abc'.isalpha() â†’ True"
isalnum = "Letters/numbers only? 'abc123'.isalnum() â†’ True"
isspace = "All whitespace? '   '.isspace() â†’ True"

# Whitespace
strip = "Remove leading/trailing space: '  hi  '.strip() â†’ 'hi'"
lstrip = "Remove leading space: '  hi'.lstrip() â†’ 'hi'"
rstrip = "Remove trailing space: 'hi  '.rstrip() â†’ 'hi'"

# Replacement
replace = "Replace substring: 'hello'.replace('l', 'r') â†’ 'herro'"

[gotchas]
strings_immutable = """
String methods return NEW strings - they don't modify the original:
text = "hello"
text.upper()  # Returns "HELLO" but text is still "hello"!

âœ“ text = text.upper()  # Now text is "HELLO"
"""
split_returns_list = """
split() always returns a list, even with one item:
"hello".split() â†’ ['hello']  # List with one string

Empty strings split to empty list:
"".split() â†’ []
"""
join_takes_iterable = """
join() is called ON the separator, takes a list:
âœ“ ", ".join(["a", "b"])  # "a, b"
âœ— ["a", "b"].join(", ")  # Wrong! No join method on lists

All items must be strings:
âœ— ",".join([1, 2, 3])  # Error!
âœ“ ",".join(["1", "2", "3"])  # "1,2,3"
âœ“ ",".join(map(str, [1, 2, 3]))  # "1,2,3"
"""

[gamepad_tutorial]
text = """
ðŸŽ® EASY MODE:
- Press Y to suggest string method
- Press RB to chain multiple methods
- D-pad UP to see all string methods
- Hold RT to see method return values
"""

[challenges]
starter = "string_parse_command"
intermediate = "string_format_display"
mastery = "string_text_adventure_parser"

[fun_factor]
type = "text_processing"
description = "Like parsing player commands or formatting game messages"
examples = ["command parsing", "dialogue formatting", "name validation", "save file parsing"]

[adaptive]
weakness_signals = ["forgetting_immutability", "join_syntax_confusion", "not_chaining"]
strength_indicators = ["method_chaining", "proper_validation", "clean_parsing"]

[examples]
basic = '''
# Parse player command
user_input = "  TAKE key  "
command = user_input.strip().lower()  # "take key"
words = command.split()  # ["take", "key"]

action = words[0]  # "take"
if len(words) > 1:
    target = words[1]  # "key"

# Format item name
item = "RUSTY_SWORD"
display_name = item.replace("_", " ").title()
print(display_name)  # "Rusty Sword"

# Validate player name
name = "Player123"
if name.isalnum() and not name.isdigit():
    print(f"Welcome, {name}!")
else:
    print("Invalid name!")
'''

advanced = '''
# Command parser with validation
def parse_command(user_input):
    """Parse and validate player command."""
    # Clean input
    cleaned = user_input.strip().lower()

    if not cleaned:
        return None, None

    # Split into words
    parts = cleaned.split()
    action = parts[0]
    target = " ".join(parts[1:]) if len(parts) > 1 else None

    return action, target

# Usage
action, target = parse_command("  ATTACK goblin chief  ")
print(f"Action: {action}, Target: {target}")
# Output: Action: attack, Target: goblin chief

# Format game dialogue
def format_dialogue(speaker, text):
    """Format NPC dialogue with box."""
    speaker_line = f"[ {speaker.upper()} ]"
    border = "=" * len(speaker_line)

    return f"{border}\n{speaker_line}\n{border}\n{text}"

print(format_dialogue("guard", "Halt! Who goes there?"))
# Output:
# ===========
# [ GUARD ]
# ===========
# Halt! Who goes there?

# Text adventure room description
def parse_room(description):
    """Extract items and exits from room description."""
    lines = description.strip().split("\n")

    items = []
    exits = []

    for line in lines:
        line = line.strip()
        if line.startswith("Item:"):
            items.append(line.replace("Item:", "").strip())
        elif line.startswith("Exit:"):
            exits.append(line.replace("Exit:", "").strip())

    return items, exits

room_text = """
Dark stone chamber with torches.
Item: rusty sword
Item: health potion
Exit: north
Exit: east
"""

items, exits = parse_room(room_text)
print(f"Items: {items}")
print(f"Exits: {exits}")
'''

[common_mistakes]
mistake_1 = "Forgetting strings are immutable: text.upper() doesn't change text"
mistake_2 = "Confusing join() syntax: it's separator.join(list), not list.join(separator)"
mistake_3 = "Not handling empty strings or None values when splitting"

[fun_facts]
fact_1 = "Python strings have 47+ built-in methods - they're incredibly powerful!"
fact_2 = "The .split() and .join() methods are inverses of each other"
fact_3 = "String methods are inspired by Perl, the 'Practical Extraction and Report Language'"
