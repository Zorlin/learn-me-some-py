# Level 6: Introspection

[concept]
id = "introspection"
name = "Introspection: Runtime Analysis"
level = 6
category = "meta_programming"
order = 0

[content]
lesson = """
## Examine Code at Runtime

Introspection lets you inspect functions, classes, and objects:

```python
import inspect

def greet(name: str, greeting: str = "Hello") -> str:
    '''Greet someone.'''
    return f"{greeting}, {name}!"

# Get signature
print(inspect.signature(greet))
# (name: str, greeting: str = 'Hello') -> str

# Get docstring
print(inspect.getdoc(greet))
# Greet someone.

# Get source code
print(inspect.getsource(greet))
```

## Inspect Parameters

```python
sig = inspect.signature(greet)

for name, param in sig.parameters.items():
    print(f"{name}: {param.annotation}")
    print(f"  default: {param.default}")

# name: <class 'str'>
#   default: <class 'inspect._empty'>
# greeting: <class 'str'>
#   default: Hello
```

## Type Checking

```python
import inspect

inspect.isfunction(greet)   # True
inspect.isclass(str)        # True
inspect.ismethod(obj.foo)   # True
inspect.ismodule(os)        # True
```

## Get Class Members

```python
import inspect

class Player:
    max_level = 100

    def __init__(self, name):
        self.name = name

    def attack(self):
        pass

# Get all members
members = inspect.getmembers(Player)

# Get just methods
methods = inspect.getmembers(Player, inspect.isfunction)
# [('__init__', ...), ('attack', ...)]
```

## Stack Inspection

```python
def who_called_me():
    frame = inspect.currentframe()
    caller = frame.f_back
    info = inspect.getframeinfo(caller)
    print(f"Called from {info.filename}:{info.lineno}")
```

## Real-World Uses

This is how frameworks work:
- **FastAPI**: Inspects signatures for validation
- **pytest**: Discovers tests and fixtures by name
- **Sphinx**: Generates docs from docstrings
"""

[content.try_it]
prompt = "Get the parameter names of a function using inspect"
starter = '''
import inspect

def calculate(a, b, operation="add"):
    pass

# Get list of parameter names

'''
solution = '''
import inspect

def calculate(a, b, operation="add"):
    pass

sig = inspect.signature(calculate)
param_names = list(sig.parameters.keys())
print(param_names)  # ['a', 'b', 'operation']
'''

[connections]
prerequisites = ["functions", "classes", "decorators"]
enables = []
used_in = []
see_also = ["decorators", "type_hints"]

[meta]
time_to_read = 55
difficulty = "expert"
tags = ["introspection", "inspect", "metaprogramming"]
