# Level 6: Descriptors

[concept]
id = "descriptors"
name = "Descriptors: Attribute Control"
level = 6
category = "meta_programming"
order = 2

[content]
lesson = """
## The Protocol Behind @property

Descriptors control what happens when you access an attribute:

```python
class Validator:
    def __init__(self, min_val, max_val):
        self.min_val = min_val
        self.max_val = max_val

    def __set_name__(self, owner, name):
        self.name = name

    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self.name)

    def __set__(self, instance, value):
        if not self.min_val <= value <= self.max_val:
            raise ValueError(f"{self.name} must be {self.min_val}-{self.max_val}")
        instance.__dict__[self.name] = value

class Game:
    score = Validator(0, 100)
    level = Validator(1, 10)

game = Game()
game.score = 50   # OK
game.score = 150  # ValueError!
```

## The Descriptor Protocol

```python
class Descriptor:
    def __set_name__(self, owner, name):
        # Called when assigned to class attribute
        self.name = name

    def __get__(self, instance, owner):
        # Called on attribute access
        pass

    def __set__(self, instance, value):
        # Called on attribute assignment
        pass

    def __delete__(self, instance):
        # Called on del
        pass
```

## Data vs Non-Data Descriptors

- **Data descriptor**: Has `__set__` → takes priority over instance
- **Non-data descriptor**: Only `__get__` → instance can override

```python
class DataDesc:
    def __get__(self, instance, owner): return "data"
    def __set__(self, instance, value): pass

class NonDataDesc:
    def __get__(self, instance, owner): return "non-data"

class Test:
    data = DataDesc()
    non_data = NonDataDesc()

t = Test()
t.__dict__['data'] = 'override'
t.__dict__['non_data'] = 'override'

print(t.data)      # "data" - descriptor wins
print(t.non_data)  # "override" - __dict__ wins
```

## Lazy Property

```python
class LazyProperty:
    def __init__(self, func):
        self.func = func
        self.name = func.__name__

    def __get__(self, instance, owner):
        if instance is None:
            return self
        value = self.func(instance)
        instance.__dict__[self.name] = value  # Cache it
        return value

class Dataset:
    @LazyProperty
    def expensive(self):
        print("Computing...")
        return sum(range(1000000))

data = Dataset()
print(data.expensive)  # Computing... 499999500000
print(data.expensive)  # 499999500000 (cached!)
```
"""

[content.try_it]
prompt = "Create a Typed descriptor that enforces type checking"
starter = '''
class Typed:
    def __init__(self, expected_type):
        self.expected_type = expected_type

    # Implement descriptor protocol

class User:
    name = Typed(str)
    age = Typed(int)

user = User()
user.name = "Alice"  # OK
user.age = "thirty"  # Should raise TypeError
'''
solution = '''
class Typed:
    def __init__(self, expected_type):
        self.expected_type = expected_type

    def __set_name__(self, owner, name):
        self.name = name

    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self.name)

    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError(f"{self.name} must be {self.expected_type}")
        instance.__dict__[self.name] = value

class User:
    name = Typed(str)
    age = Typed(int)

user = User()
user.name = "Alice"
user.age = 30
'''

[connections]
prerequisites = ["classes", "property_decorators", "magic_methods"]
enables = []
used_in = []
see_also = ["property_decorators", "magic_methods"]

[meta]
time_to_read = 60
difficulty = "expert"
tags = ["descriptors", "metaprogramming", "attributes"]
