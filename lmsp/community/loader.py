"""
Community Content Loader

Manages loading and caching of community-created content.

Supports:
- Custom Python concepts with prerequisites
- Custom challenges with test suites
- Challenge packs (themed collections)
- Content validation before loading

Self-teaching note:
This file demonstrates:
- Enum for content types (Level 4)
- Dataclasses for structured data (Level 5)
- File I/O and JSON handling (Level 3-4)
- Validation patterns (Level 5+)
- Caching strategies (Level 6)
"""

from dataclasses import dataclass, field
from typing import Optional, Any, Dict, List
from enum import Enum
from pathlib import Path
import json
from datetime import datetime


class ContentType(Enum):
    \"\"\"Types of community content.\"\"\"

    CONCEPT = \"concept\"
    CHALLENGE = \"challenge\"
    PACK = \"pack\"
    THEME = \"theme\"


@dataclass
class ContentMetadata:
    \"\"\"Metadata about a piece of community content.\"\"\"

    id: str
    title: str
    author: str
    description: str
    version: str = \"1.0.0\"

    # Content type
    content_type: ContentType = ContentType.CHALLENGE

    # Licensing and attribution
    license: str = \"CC0\"  # Creative Commons
    attribution: bool = True

    # Versioning
    created: datetime = field(default_factory=datetime.now)
    updated: datetime = field(default_factory=datetime.now)

    # Requirements
    min_lmsp_version: str = \"1.0.0\"\n    compatibility_notes: str = \"\"\n    \n    # Categories for discovery\n    categories: List[str] = field(default_factory=list)\n    tags: List[str] = field(default_factory=list)\n    \n    # Statistics\n    downloads: int = 0\n    rating: float = 0.0  # 0-5 stars\n    reviews: int = 0\n\n\n@dataclass\nclass Concept:\n    \"\"\"Community-created Python concept.\"\"\"\n    \n    # Identity\n    id: str\n    name: str\n    description: str\n    \n    # Prerequisites\n    prerequisites: List[str] = field(default_factory=list)\n    level: int = 0  # Difficulty level\n    \n    # Content\n    explanation: str = \"\"  # How to explain the concept\n    examples: List[str] = field(default_factory=list)\n    tips: List[str] = field(default_factory=list)\n    \n    # Testing\n    test_cases: List[Dict[str, Any]] = field(default_factory=list)\n\n\n@dataclass\nclass Challenge:\n    \"\"\"Community-created coding challenge.\"\"\"\n    \n    # Identity\n    id: str\n    title: str\n    description: str\n    \n    # Content\n    instructions: str\n    starter_code: str = \"\"\n    solution: str\n    \n    # Concepts involved\n    concepts: List[str] = field(default_factory=list)  # Concept IDs\n    difficulty: int = 1  # 1-5 difficulty\n    estimated_time_minutes: int = 10\n    \n    # Testing\n    test_code: str  # Pytest compatible\n    success_criteria: str = \"All tests pass\"\n    \n    # Hints\n    hints: List[str] = field(default_factory=list)\n\n\n@dataclass\nclass ContentPack:\n    \"\"\"A themed collection of content.\"\"\"\n    \n    # Identity\n    id: str\n    title: str\n    description: str\n    \n    # Content\n    concepts: List[str] = field(default_factory=list)  # Concept IDs\n    challenges: List[str] = field(default_factory=list)  # Challenge IDs\n    \n    # Learning path\n    ordering: List[str] = field(default_factory=list)  # Recommended order\n    learner_level: str = \"beginner\"  # beginner, intermediate, advanced\n    \n    # Theme\n    theme: str = \"general\"\n    learning_objective: str = \"\"\n    real_world_context: str = \"\"\n\n\nclass CommunityLoader:\n    \"\"\"\n    Manages loading community content.\n    \n    Usage:\n        loader = CommunityLoader()\n        loader.register_source(\"/path/to/community/content\")\n        concepts = loader.get_concepts()\n        challenges = loader.get_challenges()\n        pack = loader.load_pack(\"data-analysis-pack\")\n    \"\"\"\n    \n    def __init__(self, cache_dir: Optional[Path] = None):\n        \"\"\"Initialize loader.\n        \n        Args:\n            cache_dir: Optional directory for caching loaded content\n        \"\"\"\n        self.sources: List[Path] = []\n        self.cache_dir = cache_dir or Path.home() / \".cache\" / \"lmsp\" / \"community\"\n        self.cache_dir.mkdir(parents=True, exist_ok=True)\n        \n        # Loaded content\n        self._concepts: Dict[str, Concept] = {}\n        self._challenges: Dict[str, Challenge] = {}\n        self._packs: Dict[str, ContentPack] = {}\n        self._metadata: Dict[str, ContentMetadata] = {}\n    \n    def register_source(self, source_path: Path):\n        \"\"\"Register a source directory for community content.\n        \n        Args:\n            source_path: Directory containing community content\n        \"\"\"\n        source_path = Path(source_path)\n        if source_path.exists() and source_path not in self.sources:\n            self.sources.append(source_path)\n    \n    def load_concepts(self) -> List[Concept]:\n        \"\"\"Load all available concepts from registered sources.\n        \n        Returns:\n            List of loaded Concept objects\n        \"\"\"\n        for source in self.sources:\n            concepts_dir = source / \"concepts\"\n            if concepts_dir.exists():\n                for concept_file in concepts_dir.glob(\"*.json\"):\n                    try:\n                        with open(concept_file) as f:\n                            data = json.load(f)\n                            concept = Concept(**data)\n                            self._concepts[concept.id] = concept\n                    except (json.JSONDecodeError, TypeError) as e:\n                        print(f\"Warning: Failed to load concept {concept_file}: {e}\")\n        \n        return list(self._concepts.values())\n    \n    def load_challenges(self) -> List[Challenge]:\n        \"\"\"Load all available challenges from registered sources.\n        \n        Returns:\n            List of loaded Challenge objects\n        \"\"\"\n        for source in self.sources:\n            challenges_dir = source / \"challenges\"\n            if challenges_dir.exists():\n                for challenge_file in challenges_dir.glob(\"*.json\"):\n                    try:\n                        with open(challenge_file) as f:\n                            data = json.load(f)\n                            challenge = Challenge(**data)\n                            self._challenges[challenge.id] = challenge\n                    except (json.JSONDecodeError, TypeError) as e:\n                        print(f\"Warning: Failed to load challenge {challenge_file}: {e}\")\n        \n        return list(self._challenges.values())\n    \n    def load_packs(self) -> List[ContentPack]:\n        \"\"\"Load all available content packs.\n        \n        Returns:\n            List of loaded ContentPack objects\n        \"\"\"\n        for source in self.sources:\n            packs_dir = source / \"packs\"\n            if packs_dir.exists():\n                for pack_file in packs_dir.glob(\"*.json\"):\n                    try:\n                        with open(pack_file) as f:\n                            data = json.load(f)\n                            pack = ContentPack(**data)\n                            self._packs[pack.id] = pack\n                    except (json.JSONDecodeError, TypeError) as e:\n                        print(f\"Warning: Failed to load pack {pack_file}: {e}\")\n        \n        return list(self._packs.values())\n    \n    def load_all(self):\n        \"\"\"Load all content (concepts, challenges, packs).\"\"\"\n        self.load_concepts()\n        self.load_challenges()\n        self.load_packs()\n    \n    def get_concept(self, concept_id: str) -> Optional[Concept]:\n        \"\"\"Get a concept by ID.\n        \n        Args:\n            concept_id: Concept identifier\n            \n        Returns:\n            Concept if found, None otherwise\n        \"\"\"\n        return self._concepts.get(concept_id)\n    \n    def get_challenge(self, challenge_id: str) -> Optional[Challenge]:\n        \"\"\"Get a challenge by ID.\n        \n        Args:\n            challenge_id: Challenge identifier\n            \n        Returns:\n            Challenge if found, None otherwise\n        \"\"\"\n        return self._challenges.get(challenge_id)\n    \n    def get_pack(self, pack_id: str) -> Optional[ContentPack]:\n        \"\"\"Get a content pack by ID.\n        \n        Args:\n            pack_id: Pack identifier\n            \n        Returns:\n            ContentPack if found, None otherwise\n        \"\"\"\n        return self._packs.get(pack_id)\n    \n    def search_concepts(self, query: str) -> List[Concept]:\n        \"\"\"Search concepts by title or description.\n        \n        Args:\n            query: Search query\n            \n        Returns:\n            List of matching concepts\n        \"\"\"\n        query_lower = query.lower()\n        results = []\n        \n        for concept in self._concepts.values():\n            if (query_lower in concept.name.lower() or\n                query_lower in concept.description.lower()):\n                results.append(concept)\n        \n        return results\n    \n    def search_challenges(self, query: str) -> List[Challenge]:\n        \"\"\"Search challenges by title or description.\n        \n        Args:\n            query: Search query\n            \n        Returns:\n            List of matching challenges\n        \"\"\"\n        query_lower = query.lower()\n        results = []\n        \n        for challenge in self._challenges.values():\n            if (query_lower in challenge.title.lower() or\n                query_lower in challenge.description.lower()):\n                results.append(challenge)\n        \n        return results\n    \n    def get_concepts_by_level(self, level: int) -> List[Concept]:\n        \"\"\"Get concepts at a specific level.\n        \n        Args:\n            level: Difficulty level\n            \n        Returns:\n            List of concepts at that level\n        \"\"\"\n        return [c for c in self._concepts.values() if c.level == level]\n    \n    def get_challenges_by_difficulty(self, difficulty: int) -> List[Challenge]:\n        \"\"\"Get challenges at a specific difficulty.\n        \n        Args:\n            difficulty: 1-5 difficulty level\n            \n        Returns:\n            List of challenges at that difficulty\n        \"\"\"\n        return [c for c in self._challenges.values() if c.difficulty == difficulty]\n    \n    def get_packs_by_level(self, level: str) -> List[ContentPack]:\n        \"\"\"Get content packs for a specific level.\n        \n        Args:\n            level: \"beginner\", \"intermediate\", \"advanced\"\n            \n        Returns:\n            List of packs for that level\n        \"\"\"\n        return [p for p in self._packs.values() if p.learner_level == level]\n    \n    def cache_content(self, content_id: str, content: Any):\n        \"\"\"Cache loaded content locally.\n        \n        Args:\n            content_id: Identifier for the content\n            content: Content object to cache\n        \"\"\"\n        cache_file = self.cache_dir / f\"{content_id}.json\"\n        \n        try:\n            # Serialize to JSON\n            data = vars(content) if hasattr(content, '__dict__') else content\n            with open(cache_file, 'w') as f:\n                json.dump(data, f, indent=2, default=str)\n        except (IOError, TypeError) as e:\n            print(f\"Warning: Failed to cache {content_id}: {e}\")\n    \n    def get_stats(self) -> Dict[str, int]:\n        \"\"\"Get statistics about loaded content.\n        \n        Returns:\n            Dictionary with concept_count, challenge_count, pack_count\n        \"\"\"\n        return {\n            \"concept_count\": len(self._concepts),\n            \"challenge_count\": len(self._challenges),\n            \"pack_count\": len(self._packs),\n        }\n\n\n# Self-teaching note:\n#\n# This file demonstrates:\n# - Enum for type safety (Level 4)\n# - Dataclasses for data structures (Level 5)\n# - File I/O and JSON handling (Level 3-4)\n# - Path manipulation (Level 3+)\n# - Search and filtering patterns (Level 4-5)\n# - Caching strategies (Level 5+)\n# - Error handling (Level 3: try/except)\n#\n# Community content enables:\n# 1. User-created lessons and challenges\n# 2. Sharing of learning experiences\n# 3. Customization of curriculum\n# 4. Building learning communities\n#\n# Prerequisites:\n# - Level 3: Functions, classes, file I/O\n# - Level 4: Collections, JSON, enums\n# - Level 5: Dataclasses, type hints\n# - Level 6: Design patterns, caching\n"}}]

</invoke>